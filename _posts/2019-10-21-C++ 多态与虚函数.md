---
layout:     post
title:      C++ 多态与虚函数
subtitle:   Abstract Class
date:       2019-10-21
author:     kevin
header-img: img/green-bg.jpg
catalog: true
tags:
    - cpp
	- reading notes
---





## preface



想起之前别人问过我知不知道 C++ 抽象类是什么，我心想，抽象类不就是面向对象的一种说法吗，但是具体怎么说还真不知道，后来才知道当时有多傻，抽象类在 C++ 里面是有具体定义的，所以特意记录一下，顺便当作复习 C++ 了.



## 多态概念



都知道面向对象的一个特征就是多态，那么为什么我们需要多态呢，通常来讲就是因为我们需要一个方法在不同的对象中的表现不同，一般这种方式是通过派生类重写基类的函数或者在基类中定义虚函数来实现。



## 虚函数



虚函数的声明很简单，只需要在类型的前面加上一个 `virtual` 关键字，如下这样就声明了一个虚函数



```cpp
virtual void func();
```



至于我们为什么要使用虚函数呢？我们来看个例子：



```cpp
class Animal{
public:
    Animal(){}
    void shout(){
        cout << "Animal is shouting!" << endl;
    }
};

class cat:public Animal{
public:
    cat(){}
    void shout(){
        cout << "cat is shouting!" << endl;
    }
};

```



上面定义了两个类， `cat` 类继承了 `Animal` 这个基类，并且改写了基类的 `shout` 方法，那么有下面几种情况来帮助我们理解虚函数的意义：



### 1.用对象直接调用



```cpp
Animal animal;
cat tom;
animal.shout();
tom.shout();
```



由于在基类和派生类中的 shout 方法是不同的，所以直接调用的话，会调用各个类中的方法，因此输出为



```
Animal is shouting!
cat is shouting!
```



### 2.通过指针或者引用调用(不带 virtual 关键字)



现在我们来创建之前两个对象的引用，看看这回调用函数会出现什么情况：



```
Animal is shouting!
Animal is shouting!
```



为什么 b 创建的是 cat 类的引用但他还是调用了 Animal 类的方法呢？再继续用指针指向这两个对象，同时调用 shout 方法：



```cpp
Animal *a = &animal;
Animal *b = &tom;
a->shout();
b->shout();
```



输出依然跟上面通过引用调用一样，这是为啥呢，**原因就是通过这种方式调用的话，程序会根据引用类型或者指针类型来决定调用哪个方法，相反，如果方法带有 `virtual` 关键字，程序会根据引用或指针指向的对象来选择方法**，就像下面这样：



```cpp
class Animal{
public:
    Animal(){}
    virtual void shout(){
        cout << "Animal is shouting!" << endl;
    }
};

class cat:public Animal{
public:
    cat(){}
    virtual void shout(){
        cout << "cat is shouting!" << endl;
    }
};
```



### 2.通过指针或者引用调用(带 virtual 关键字)



用上面的例子，在基类中我们用 `virtual` 关键字声明了一个虚函数，在派生类中这个函数自动变成了虚函数，但我们还是在派生类中也声明了 `virtual` 关键字，这也可以让人更加清楚哪些方法是虚函数。



```cpp
Animal *a = &animal;
Animal *b = &tom;
a->shout();
b->shout();
```



这里的输出就会变成：



```cpp
Animal is shouting!
cat is shouting!
```



因为程序会从指针指向的对象那里判断要调用哪个函数(用引用同理)，可以看到，这种虚函数的方法十分好用，当然，如果我们想在派生类中使用基类的方法时，要加上作用解析符，这里如果 tom 对象想调用 Aminal 类的 shout 方法时，就要写成 `b->Animal::shout()` 的形式。



>  如果要在派生类中重新定义基类的方法，通常会将基类的方法声明为虚的，并且，通常还会给基类声明一个**虚析构函数**



## 虚析构函数



我们来简述一下派生类的构造函数和析构函数，那就是，在派生类对象创建的时候，程序会首先创建基类对象，这意味着基类对象应该在程序进入派生类构造函数之前就被创建，因此我们用**成员初始化列表**来干这事。我们将上面的类稍做一些改动：



```cpp
class Animal{
public:
    Animal(int a, char g){
        age = a;
        gender = g;
    }
    virtual void shout(){
        cout << "Animal is shouting!" << endl;
    }
    virtual ~Animal(){}
private:
    int age;
    char gender;
};


class cat:public Animal{
public:
    cat(int a, char f, string c):Animal(a, f),color(c){}
    virtual void shout(){
        cout << "cat is shouting!" << endl;
    }
private:
    string color;
};
```



这样的话，派生类的构造函数就得调用基类的构造函数了，实际上这也很合道理，没有爸爸哪有儿子呢？**如果没有写基类的构造函数的话，系统就会自动调用基类的默认构造函数**，所以还是不要这么干。析构的顺序是先析构派生类对象，再调用基类的析构函数来析构基类，这也很合道理，肯定先析构掉儿子再析构爸爸一步一步来的嘛，直接析构爸爸的话儿子肯定直接没了。。



那这里又有一个重要概念，那就**是虚析构函数** ，虚析构函数也就是析构函数，都是负责回收对象的内存以及一些清理工作，那么他具体有什么作用呢？



```cpp
virtual ~Animal(){}
```



