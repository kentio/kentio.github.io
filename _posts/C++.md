## 0x01 C和C++的区别 

1. C 是面向过程的编程，C++ 是面向对象的编程，主要包括：
	* 封装：隐藏了代码细节，只留接口给用户调用
	* 继承：继承父类的数据和方法，扩展已经存在的模块，实现代码重用
	* 多态：通过派生类重写父类的虚函数，实现了接口的重用，也就是 “一个接口，多种实现”

2. C++ 支持函数重载， C 不支持
3. C++ 有引用，C 中不存在引用的概念
4. 动态管理内存方式不同，C 使用 malloc/free，C++ 除此之外还有 new/delete 关键字
5. C++ 支持重载的概念， C 不支持

## 0x02 #include<file.h> 和 #include "file.h" 的区别

#include<file.h> 先从标准库的路径中寻找文件，找不到再去工作目录

#include"file.h" 是先从工作目录中寻找文件，找不到再去标准库寻找

## 0x03 C++ 文件编译与执行的四个阶段

1. 预处理：根据文件中的预处理指令来修改源文件的内容
2. 编译：把源代码编译成汇编代码
3. 汇编：把汇编代码翻译成目标二进制机器指令
4. 链接：链接目标代码生成可执行程序，可执行程序包括源程序的机器码和相关的描述信息，如程序多大，占用多少内存空间等

## 0x04 #define 和 const 有什么区别

1. 

## 0x05 C++ 深拷贝和浅拷贝的区别



1. 对拥有动态成员的对象进行浅拷贝后，一个对象改变，另一个对象也会跟着改变



## 0x06 C++构造函数参数列表初始化与直接在函数内部初始化有何区别



这个问题之前也有人问过我，但是我回答不上来，后来在知乎上找到了答案：



当实例化一个类的对象时，实质上会发生下面 5 步：

1. 分配 memory 给对象 
2. 调用类相应的构造函数
3. **先进行初始化列表的初始化**
4. **再进入构造函数体内，进行一些赋值什么的**
5. 跳出函数体，控制权还给调用者



因此可以看到，如果写在函数内部的话，它是先用默认构造初始化了一遍，然后又去函数内部赋值，就很影响效率，所以最好优先使用初始化列表。
