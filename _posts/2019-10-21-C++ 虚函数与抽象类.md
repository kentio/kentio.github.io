---

layout:     post
title:      C++ 虚函数与抽象类
subtitle:   Abstract Class
date:       2019-10-21
author:     kevin
header-img: img/green-bg.jpg
catalog: true
tags:
    - cpp
    - reading notes
---



## preface



想起之前别人问过我知不知道 C++ 抽象类是什么，我心想，抽象类不就是面向对象的一种说法吗，但是具体怎么说还真不知道，后来才知道当时有多傻，抽象类在 C++ 里面是有具体定义的，所以特意记录一下，顺便当作复习 C++ 了.



## 多态概念



都知道面向对象的一个特征就是多态，那么为什么我们需要多态呢，通常来讲就是因为我们需要一个方法在不同的对象中的表现不同，一般这种方式是通过派生类重写基类的函数或者在基类中定义虚函数来实现。



## 虚函数



虚函数的声明很简单，只需要在类型的前面加上一个 `virtual` 关键字，如下这样就声明了一个虚函数



```cpp
virtual void func();
```



至于我们为什么要使用虚函数呢？我们来看个例子：



```cpp
class Animal{
public:
    Animal(){}
    void shout(){
        cout << "Animal is shouting!" << endl;
    }
};

class cat:public Animal{
public:
    cat(){}
    void shout(){
        cout << "cat is shouting!" << endl;
    }
};

```



上面定义了两个类， `cat` 类继承了 `Animal` 这个基类，并且改写了基类的 `shout` 方法，那么有下面几种情况来帮助我们理解虚函数的意义：



### 1.用对象直接调用



```cpp
Animal animal;
cat tom;
animal.shout();
tom.shout();
```



由于在基类和派生类中的 shout 方法是不同的，所以直接调用的话，会调用各个类中的方法，因此输出为



```
Animal is shouting!
cat is shouting!
```



### 2.通过指针或者引用调用(不带 virtual 关键字)



现在我们来创建之前两个对象的引用，看看这回调用函数会出现什么情况：



```
Animal is shouting!
Animal is shouting!
```



为什么 b 创建的是 cat 类的引用但他还是调用了 Animal 类的方法呢？再继续用指针指向这两个对象，同时调用 shout 方法：



```cpp
Animal *a = &animal;
Animal *b = &tom;
a->shout();
b->shout();
```



输出依然跟上面通过引用调用一样，这是为啥呢，**原因就是通过这种方式调用的话，程序会根据引用类型或者指针类型来决定调用哪个方法，相反，如果方法带有 `virtual` 关键字，程序会根据引用或指针指向的对象来选择方法**，就像下面这样：



```cpp
class Animal{
public:
    Animal(){}
    virtual void shout(){
        cout << "Animal is shouting!" << endl;
    }
};

class cat:public Animal{
public:
    cat(){}
    virtual void shout(){
        cout << "cat is shouting!" << endl;
    }
};
```



### 2.通过指针或者引用调用(带 virtual 关键字)



用上面的例子，在基类中我们用 `virtual` 关键字声明了一个虚函数，在派生类中这个函数自动变成了虚函数，但我们还是在派生类中也声明了 `virtual` 关键字，这也可以让人更加清楚哪些方法是虚函数。



```cpp
Animal *a = &animal;
Animal *b = &tom;
a->shout();
b->shout();
```



这里的输出就会变成：



```cpp
Animal is shouting!
cat is shouting!
```



因为程序会从指针指向的对象那里判断要调用哪个函数(用引用同理)，可以看到，这种虚函数的方法十分好用，当然，如果我们想在派生类中使用基类的方法时，要加上作用解析符，这里如果 tom 对象想调用 Aminal 类的 shout 方法时，就要写成 `b->Animal::shout()` 的形式。



>  如果要在派生类中重新定义基类的方法，通常会将基类的方法声明为虚的，并且，通常还会给基类声明一个**虚析构函数**



## 虚析构函数



我们来简述一下派生类的构造函数和析构函数，那就是，在派生类对象创建的时候，程序会首先创建基类对象，这意味着基类对象应该在程序进入派生类构造函数之前就被创建，因此我们用**成员初始化列表**来干这事。我们将上面的类稍做一些改动：



```cpp
class Animal{
public:
    Animal(int a, char g){
        age = a;
        gender = g;
    }
    virtual void shout(){
        cout << "Animal is shouting!" << endl;
    }
    virtual ~Animal(){}
private:
    int age;
    char gender;
};


class cat:public Animal{
public:
    cat(int a, char f, string c):Animal(a, f),color(c){}
    virtual void shout(){
        cout << "cat is shouting!" << endl;
    }
private:
    string color;
};
```



这样的话，派生类的构造函数就得调用基类的构造函数了，实际上这也很合道理，没有爸爸哪有儿子呢？**如果没有写基类的构造函数的话，系统就会自动调用基类的默认构造函数**，所以还是不要这么干。析构的顺序是先析构派生类对象，再调用基类的析构函数来析构基类，这也很合道理，肯定先析构掉儿子再析构爸爸一步一步来的嘛，直接析构爸爸的话儿子肯定直接没了。。



那这里又有一个重要概念，那就**是虚析构函数** ，虚析构函数也就是析构函数，都是负责回收对象的内存以及一些清理工作，那么他具体有什么作用呢？



```cpp
virtual ~Animal(){}
```



### 析构函数非虚函数情况



依然是上面的例子，我们给每个类的析构函数做点改动，如果析构函数不是虚函数，那么同理，当我们通过指针指向对象或者引用一个对象时，系统只会调用该指针类型或信用类型的析构函数



```cpp
class Animal{
public:
    // ignore some code
    ~Animal(){
        cout << "Animal destructor called!" << endl;
    }
};

class cat:public Animal{
public:
	// ignore some code
    ~cat(){
        cout << "cat destructor called!" << endl;
    }
};
```



我们来用指针新建两个对象，一个指向 Animal 类对象，一个指向 cat 类对象



```cpp
    Animal *a = new Animal(0, 'f');
    Animal *b = new cat(1, 'm', "brown");
    delete a;
    cout << "--------------------" << endl;
    delete b;
```



这段代码执行后的输出为：



```
Animal destructor called!
--------------------
Animal destructor called!
```



说明这两个对象都只是调用了 Animal 基类的析构函数，析构函数非虚函数的情况下系统只调用对应于指针类型的 析构函数，这里，即使 b 指向的是一个派生的 cat 类对象，但是派生类的析构函数并不会被调用。



### 析构函数为虚函数



```cpp
class Animal{
public:
    // ignore some code
    virtual ~Animal(){
        cout << "Animal destructor called!" << endl;
    }
};

class cat:public Animal{
public:
	// ignore some code
    virtual ~cat(){
        cout << "cat destructor called!" << endl;
    }
};
// some code 
Animal *a = new Animal(0, 'f');
Animal *b = new cat(1, 'm', "brown");
delete a;
cout << "--------------------" << endl;
delete b;
```



当声明了析构函数为虚函数时，系统就会根据指针指向的对象类型来判断该调用哪个析构函数，上述代码的输出如下，可以看到 b 先调用了派生类 cat 的析构函数再调用基类的析构函数，这就很符合析构的顺序，不会造成意外的内存泄露等。



因此，**虚析构函数可以确保正确的析构函数系列被调用**。虽然有时候可能析构函数这种正确的调用顺序并不是很重要，如上例，这是因为析构函数并没有执行什么操作，然而。如果派生类 cat 包含一个执行了某种操作的析构函数，那么基类 Animal 必须要有一个虚析构函数，即使这个虚析构函数什么都不做。



## 静态联编和动态联编





## 抽象(基)类



## 