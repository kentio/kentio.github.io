---
layout: post
title: python多线程多进程脚本
subtitle: 
date: 2020-03-20
author: kevin
header-img: img/green-bg.jpg
catalog: true
tags:
    - python
---





## 多线程



### 基本用法



python 中一般用 `threading` 模块来实现多线程，一种实现多线程的脚本如下，最终的运行时间为 1s 多一点点，`join` 表示将子线程加入主线程，等待子线程都运行完才会继续往下执行。

```python
import time
import threading

def func(n):
    print("current task：", n)
    time.sleep(1)

if __name__ == "__main__":
    t = time.time()
    t1 = threading.Thread(target=func, args=("thread 1",))
    t2 = threading.Thread(target=func, args=("thread 2",))
    t1.start()
    t2.start()
    # 加入主线程
    t1.join()
    t2.join()
    print('done')
    print(time.time() - t)
```



还有一种写法是通过继承 `threading.Thread` 定义自己的线程类，重构一下父类的 `run` 方法，注意这个 `run` 不能写成其他的函数



> This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass.

```python 
import time
import threading

class MyThread(threading.Thread):
    def __init__(self, n):
        # 重构run函数必须要写
        super(MyThread, self).__init__()  
        self.n = n

    def run(self):
        print("current task：", self.n)
        time.sleep(1)

if __name__ == "__main__":
    t = time.time()
    t1 = MyThread("thread 1")
    t2 = MyThread("thread 2")
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print('done')
    print(time.time() - t)
```



想开多个线程可以用 for 循环先让线程 start 再用一个 for 循环让所有线程都 join

```python
for i in range(200):
    t = threading.Thread(target=func,args=('thread {}'.format(i),))
    t.start()
for i in range(200):
    t.join()
```



### 互斥锁



线程之间数据是共享的，当多个线程对某一个共享数据进行操作时，就需要考虑到线程安全问题。`threading` 模块中定义了 `Lock` 类，提供了互斥锁的功能来保证多线程情况下数据的正确性。

```python 
#创建锁
mutex = threading.Lock()
#锁定
mutex.acquire()
#释放
mutex.release()
```

除了 `Lock` 类还有一个 `RLock` 递归锁，`RLock` 允许在同一线程中被多次 acquire, 而 ``Lock` 却不允许这种情况，否则会产生死锁。 如果使用 `RLock`，那么 acquire 和 release 必须成对出现，即调用了 n 次 acquire，必须调用 n 次的 release 才能真正释放所占用的琐。

```python
rLock = threading.RLock()  #RLock对象
rLock.acquire()
rLock.acquire()    #在同一线程内，程序不会堵塞。
rLock.release()
rLock.release()
```



看下面这个例子，没有加锁，两个线程共享对全局变量 balance 并且对其执行相关函数，由于这个函数里面的操作并不是原子操作，CPU 对线程的调度是随机的，就有可能两个线程同时在操作这个变量，第一个线程还没有操作完毕第二个线程就对当前没有操作完的变量再次操作，所以就会造成结果被改乱

```python
import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
```



上面这个代码的输出有很多种情况，非常随机，如果对操作变量的地方加上锁的话，当某个线程执行到该函数我们就说它获得了锁，因此其他线程不能同时操作这个变量，只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突

```python
import time, threading

# 假定这是你的银行存款:
balance = 0
# 定义一个锁
lock = threading.Lock()

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        # 先获得锁
        lock.acquire()
        change_it(n)
        # 改完了要记得释放锁
        lock.release()

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
```



不过加上了锁感觉跟没有用多线程是一样的，甚至有时候速度还比单线程更慢，u1s1，python 速度慢不是吹的，也就爬虫用用多线程吧



> Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。



## 多进程



### 基本用法



Python 要进行多进程操作，需要用到 `muiltprocessing` 库，其中的 `Process` 类跟 `threading` 模块的 `Thread` 类很相似，第一种方法直接用 `Process` 来声明一个对象

```python
from multiprocessing import Process  

def show(name):
    print("Process name is " + name)

if __name__ == "__main__": 
    proc = Process(target=show, args=('subprocess',))  
    proc.start()  
    proc.join()
```



第二种方法和上面的一样，也是重写 `run` 方法，所以和多线程的表示还是挺像的

```python
from multiprocessing import Process
import time

class MyProcess(Process):
    def __init__(self, name):
        super(MyProcess, self).__init__()
        self.name = name

    def run(self):
        print('process name :' + self.name)
        time.sleep(1)

if __name__ == '__main__':
    for i in range(3):
        p = MyProcess(str(i))
        p.start()
    for i in range(3):
        p.join()
```



## 进程间通信

