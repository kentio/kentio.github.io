---
layout:     post
title:      C++ 经典面试题
subtitle:   Continuous update :D
date:       2019-10-14
author:     kevin
header-img: img/green-bg.jpg
catalog: true
tags:
    - cpp
---



## 0x01 C和C++的区别

1. C 是面向过程的编程，C++ 是面向对象的编程，主要包括：
	* 封装：隐藏了代码细节，只留接口给用户调用
	* 继承：继承父类的数据和方法，扩展已经存在的模块，实现代码重用
	* 多态：通过派生类重写父类的虚函数，实现了接口的重用，也就是 “一个接口，多种实现”
2. C++ 支持函数重载， C 不支持
3. C++ 有引用，C 中不存在引用的概念
4. 动态管理内存方式不同，C 使用 malloc/free，C++ 除此之外还有 new/delete 关键字
5. C++ 支持重载的概念， C 不支持



## 0x02 #include<file.h> 和 #include "file.h" 的区别

#include<file.h> 先从标准库的路径中寻找文件，找不到再去工作目录

#include"file.h" 是先从工作目录中寻找文件，找不到再去标准库寻找



## 0x03 C++ 文件编译与执行的四个阶段

1. 预处理：根据文件中的预处理指令来修改源文件的内容
2. 编译：把源代码编译成汇编代码
3. 汇编：把汇编代码翻译成目标二进制机器指令
4. 链接：链接目标代码生成可执行程序，可执行程序包括源程序的机器码和相关的描述信息，如程序多大，占用多少内存空间等



## 0x04 #define 和 const 有什么区别

1. 

## 0x05 C++ 深拷贝和浅拷贝的区别



1. 对拥有动态成员的对象进行浅拷贝后，一个对象改变，另一个对象也会跟着改变



## 0x06 C++构造函数参数列表初始化与直接在函数内部初始化有何区别



这个问题之前也有人问过我，但是我回答不上来，后来在知乎上找到了答案：



当实例化一个类的对象时，实质上会发生下面 5 步：

1. 分配 memory 给对象 
2. 调用类相应的构造函数
3. **先进行初始化列表的初始化**
4. **再进入构造函数体内，进行一些赋值什么的**
5. 跳出函数体，控制权还给调用者



因此可以看到，如果写在函数内部的话，它是先用默认构造初始化了一遍，然后又去函数内部赋值，就很影响效率，所以最好优先使用初始化列表。



> **基类的构造函数只能通过列表初始化来完成！ 上次有人问我一般在什么情况下用列表初始化，原来就是这个场景！**



## 0x07 引用与指针有什么区别



1. 引用必须被初始化，指针不必初始化
2. 引用初始化之后就不能被改变，指针可以改变指向的对象
3. 引用不能指向空值，指针可以



## 0x08 堆和栈有什么区别



1. 堆是由 `new` 分配的内存块，需要程序员手动释放，否则程序结束后会被操作系统自动回收； 栈存放函数的参数值，局部变量，由编译器自动分配释放（保护现场就是用栈）
2. 堆的分配需要使用频繁的 new/delete ，造成内存空间的不连续，会有大量的碎片（**操作系统是用链表来储存空闲的内存地址**）
3. 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小
4. 申请栈的空间大小有限制（类比汇编，栈段的大小不能超过 64 kB），申请空间超过栈的剩余空间时，会提示 overflow ，而堆的大小受限于系统中的有效虚拟内存，因此灵活度高，空间也比较大



```cpp
int a = 0; //全局初始化区 
char *p1; //全局未初始化区 
main() 
{ 
    int b; //栈 
    char s[] = "abc"; //栈 
    char *p2; //栈 
    char *p3 = "123456"; //123456\0在常量区，p3在栈上。 
    static int c =0； //全局（静态）初始化区 
    p1 = (char *)malloc(10); //堆 
    p2 = (char *)malloc(20);  //堆 
}
```



## 0x09 struct 和 union 有什么区别



1. struct 中的每个成员都有自己独立的地址，它们是同时存在的，union 中的所有成员占用同一段内存，它们不能同时存在，union 里面的数据存放在同一个地址开始的内存单元
2. struct 的大小是字节对齐之后所有成员长度的总和，union 的大小是内存对齐后最长的数据成员的长度，union 就是为了节省空间才设计出来的
3. **union 的好处是可以用来测试 CPU 是大端模式还是小端模式**







