---
layout:     post
title:      C++ 经典面试题
subtitle:   Continuous update :D
date:       2019-10-14
author:     kevin
header-img: img/green-bg.jpg
catalog: true
tags:
    - cpp
---



## 0x01 C和C++的区别

1. C 是面向过程的编程，C++ 是面向对象的编程，主要包括：
	* 封装：隐藏了代码细节，只留接口给用户调用
	* 继承：继承父类的数据和方法，扩展已经存在的模块，实现代码重用
	* 多态：通过派生类重写父类的虚函数，实现了接口的重用，也就是 “一个接口，多种实现”

2. C++ 支持函数重载， C 不支持
3. C++ 有引用，C 中不存在引用的概念
4. 动态管理内存方式不同，C 使用 malloc/free，C++ 除此之外还有 new/delete 关键字
5. C++ 支持重载的概念， C 不支持

## 0x02 #include<file.h> 和 #include "file.h" 的区别

#include<file.h> 先从标准库的路径中寻找文件，找不到再去工作目录

#include"file.h" 是先从工作目录中寻找文件，找不到再去标准库寻找

## 0x03 C++ 文件编译与执行的四个阶段

1. 预处理：根据文件中的预处理指令来修改源文件的内容
2. 编译：把源代码编译成汇编代码
3. 汇编：把汇编代码翻译成目标二进制机器指令
4. 链接：链接目标代码生成可执行程序，可执行程序包括源程序的机器码和相关的描述信息，如程序多大，占用多少内存空间等

## 0x04 #define 和 const 有什么区别

1. 

## 0x05 C++ 深拷贝和浅拷贝的区别



1. 对拥有动态成员的对象进行浅拷贝后，一个对象改变，另一个对象也会跟着改变



## 0x06 C++构造函数参数列表初始化与直接在函数内部初始化有何区别



这个问题之前也有人问过我，但是我回答不上来，后来在知乎上找到了答案：



当实例化一个类的对象时，实质上会发生下面 5 步：

1. 分配 memory 给对象 
2. 调用类相应的构造函数
3. **先进行初始化列表的初始化**
4. **再进入构造函数体内，进行一些赋值什么的**
5. 跳出函数体，控制权还给调用者



因此可以看到，如果写在函数内部的话，它是先用默认构造初始化了一遍，然后又去函数内部赋值，就很影响效率，所以最好优先使用初始化列表。



> **基类的构造函数只能通过列表初始化来完成！ 上次有人问我一般在什么情况下用列表初始化，原来就是这个场景！**





## 0x07 引用与指针有什么区别



1. 引用必须被初始化，指针不必
2. 引用初始化之后就不能被改变，指针可以改变指向的对象
3. 引用不能指向空值，指针可以



## 0x08 堆和栈有什么区别



> 堆



## 0x09 struct 和 union 有什么区别



1. struct 中的每个成员都有自己独立的地址，它们是同时存在的，union 中的所有成员占用同一段内存，它们不能同时存在，union 里面的数据存放在同一个地址开始的内存单元
2. struct 的大小是字节对齐之后所有成员长度的总和，union 的大小是内存对齐后最长的数据成员的长度，union 就是为了节省空间才设计出来的
3. **union 的好处是可以用来测试 CPU 是大端模式还是小端模式**







